package sr.core;

import sr.core.vec3.Velocity;
import sr.core.vec4.FourVelocity;

/** 
 Kinematic (Wigner) rotation corresponding to the addition of two velocities.
 The two velocities are usually not in the same line.
*/
public final class KinematicRotation {

  /** 
   Factory method. 
   The speeds must be in the range [0,1), excluding 1.
   If either speed is 0, then the kinematic rotation is 0. 
  */
  public static KinematicRotation of(Velocity one, Velocity two) {
    return new KinematicRotation(one, two);
  }
  
  /** 
   Kinematic (Wigner) rotation angle.
   <P>WARNING: This method can only be used when the two given velocities are in the XY plane.
    
   @return range -π..+π; if either speed is 0, then return 0. 
  */
  public double θwIfXYPlane() {
    double result = 0.0;
    if (noZeroes()) {
      if (noZComponents()) {
        //Silberstein's textbook points out that this is one way of calculated the kinematic rotation:
        Velocity a = veloAddition();
        Velocity b = veloAdditionReversed();
        //should this be a.turnsTo(b) ? No, I believe this is correct. 
        //For circular motion, this angle is 'retrograde' with respect to the sense of the given circular motion.
        result = b.turnsTo(a);
      }
      else {
        throw new IllegalArgumentException("Velocities must be in the XY plane for this method to be used: " + veloOne + " " + veloTwo);
      }
    }
    return result;
  }
  
  /** 
   Kinematic (Wigner) rotation angle.
   This implementation calculates the angular defect of a triangle on the unit hyperboloid, generated by the given (four-)velocities, 
   and a velocity at rest.
   
   @return range 0..-π; the minus sign indicates that the sense of rotation is opposite that which turns the first velocity into the second;
   if either speed is 0, then return 0. 
  */
  public double θw() {
    double result = 0.0;
    if (noZeroes()) {
      FourVelocity a = FourVelocity.of(veloOne);
      FourVelocity at_rest = FourVelocity.of(Velocity.zero());
      FourVelocity c = FourVelocity.of(veloTwo);
      HyperbolicTriangle triangle = HyperbolicTriangle.fromFourVelocities(a, at_rest, c);
      result = -triangle.angularDefect();
    }
    return result;
  }

  private Velocity veloOne;
  private Velocity veloTwo;

  private KinematicRotation(Velocity one, Velocity two) {
    check(one, two);
    this.veloOne = one;
    this.veloTwo = two;
  }

  private Velocity veloAddition() {
    return VelocityTransformation.unprimedVelocity(
      veloOne, 
      veloTwo 
    );
  }
  
  /** Reverse the order of parameters to the transformation formula. */
  private Velocity veloAdditionReversed() {
    return VelocityTransformation.unprimedVelocity(
      veloTwo, 
      veloOne 
    );
  }
  
  private void check(Velocity... velocities) {
    for(Velocity v : velocities) {
       if (v.magnitude() == 1.0) {
         throw new IllegalArgumentException("Speed cannot be 1.");
       }
    }
  }
  
  private boolean noZeroes() {
    return 
      veloOne.magnitude() > 0 && 
      veloTwo.magnitude() > 0
   ;
  }
  
  private boolean noZComponents() {
    return 
      veloOne.z() == 0.0 && 
      veloTwo.z() == 0
    ;
  }

}